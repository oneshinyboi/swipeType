<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>swipeType</title>
    <script>
        window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };
    </script>
    <script defer src="/_vercel/insights/script.js"></script>
    <style>
        body { font-family: system-ui, sans-serif; background: #eee; width: 100%; max-width: 700px; margin: 0 auto; padding: 40px 20px; box-sizing: border-box; }
        div { opacity: 0.8; }
        h1 { font-size: 1.5em; }
        input { width: 100%; padding: 8px; font-size: 1em; border: 1px solid #ccc; box-sizing: border-box; font-family: inherit; }
        #status { margin-top: 8px; font-size: 0.9em; display: flex; justify-content: space-between; }
        #status .typing-stats { text-align: right; }
        #results { margin-top: 8px; margin-bottom: 16px; }
        #keyboard-container { position: relative; margin-top: 16px; margin-bottom: 16px; width: 100%; aspect-ratio: 13 / 3.2; }
        #keyboard { position: absolute; width: 100%; height: 100%; }
        .key { position: absolute; width: 7%; height: 28%; background: #fff; border: 1px solid #ccc; border-radius: 5px; display: flex; align-items: center; justify-content: center; font-size: 0.9em; text-transform: uppercase; box-sizing: border-box; transition: background-color 0.15s; }
        .key.active { background: #a8d4ff; }
        #path-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #explanation { margin-top: 16px; }
        #explanation h2 { font-size: 1.1em; }
        .prediction { display: flex; align-items: baseline; padding: 4px 0; }
        .prediction .word { flex: 1; }
        .prediction .score { width: 80px; text-align: right; margin-right: 24px; }
        .prediction .popularity { width: 80px; text-align: right; }
        a { color: #348; }
        .mode-toggle { display: flex; gap: 8px; margin-bottom: 12px; }
        .mode-toggle button { padding: 6px 12px; border: 1px solid #ccc; background: #fff; border-radius: 4px; cursor: pointer; font-family: inherit; font-size: 0.9em; }
        .mode-toggle button.active { background: #348; color: #fff; border-color: #348; }
        #sentence-container { display: none; margin-bottom: 12px; padding: 12px; background: #fff; border: 1px solid #ccc; border-radius: 4px; }
        #sentence-container.visible { display: block; }
        #sentence-display { font-size: 1.1em; min-height: 1.4em; }
        #sentence-display .cursor { display: inline-block; width: 2px; height: 1em; background: #348; margin-left: 4px; animation: blink 1s infinite; }
        @keyframes blink { 0%, 50% { opacity: 1; } 51%, 100% { opacity: 0; } }
        #sentence-stats { font-size: 0.85em; color: #666; margin-top: 8px; }
    </style>
</head>
<body>
    <h1>swipeType</h1>
    <div class="mode-toggle">
        <button id="mode-word" class="active">Word Mode</button>
        <button id="mode-sentence">Sentence Mode</button>
    </div>
    <div id="sentence-container">
        <div id="sentence-display"><span class="cursor"></span></div>
        <div id="sentence-stats"></div>
    </div>
    <input type="text" id="swipe" placeholder="Type a swipe pattern..." disabled>
    <div id="status">Loading...</div>
    <div id="results"></div>
    <div id="keyboard-container">
        <div id="keyboard"></div>
        <canvas id="path-canvas"></canvas>
    </div>
    <details style="margin-top: 12px; font-size: 0.85em; color: #555; cursor: pointer;">
        <summary>Help & Usage</summary>
        <p style="margin-top: 8px; line-height: 1.4;">
            Draw patterns across the keyboard to type. SwipeType predicts words based on your path and automatically commits choices as you continue typing. Use <strong>1-5</strong> to select specific predictions and <strong>Backspace</strong> to undo words.
        </p>
    </details>
    <div id="explanation">
        <p>Swipe typing lets you draw a path across the keyboard instead of tapping individual keys. This predictor matches your input pattern against a word list.</p>
        <p>Each word is converted to a path on a QWERTY keyboard layout. The algorithm uses <a href="https://en.wikipedia.org/wiki/Dynamic_time_warping">Dynamic Time Warping (DTW)</a> to measure how similar your swipe path is to each word's path. Words with similar paths get low scores.</p>
        <p>Word frequency from a corpus is used as a tiebreaker—common words rank higher when paths are equally close.</p>
        <p>Try these swipe patterns:</p>
        <ul>
            <li><em>asdfghjkl;poiuygfdsascsa</em> → alpaca</li>
            <li><em>poiuytrernmngyuijnb</em> → penguin</li>
        </ul>
        <h2>Optimizations</h2>
        <p>To run DTW (an O(n×m) algorithm) against 333k words in milliseconds entirely client-side, we needed some optimizations. The engine is written in Rust and compiled to WebAssembly:</p>
        <ul>
            <li><strong>Sakoe-Chiba band</strong> — constrain DTW to a diagonal band, reducing complexity to O(n×w)</li>
            <li><strong>Early termination</strong> — prune candidates mid-computation if partial score exceeds current best</li>
            <li><strong>O(n) space</strong> — keep only two rows of the DTW matrix in memory</li>
            <li><strong>Start/end penalties</strong> — penalize words whose first or last character differs from the input path endpoints</li>
        </ul>
        <p><a href="https://github.com/ZimengXiong/swipePredictor">Source</a></p>
    </div>
    <script type="module">
        import init, { init_dictionary, predict_wasm } from './swipe_web.js';
        const DICT_URL = "https://raw.githubusercontent.com/ZimengXiong/swipePredictor/refs/heads/master/word_freq.txt";
        const input = document.getElementById('swipe');
        const status = document.getElementById('status');
        const results = document.getElementById('results');
        const keyboard = document.getElementById('keyboard');
        const canvas = document.getElementById('path-canvas');
        const ctx = canvas.getContext('2d');
        const KEYBOARD_LAYOUT = {
            'q': [0, 0], 'w': [1, 0], 'e': [2, 0], 'r': [3, 0], 't': [4, 0],
            'y': [5, 0], 'u': [6, 0], 'i': [7, 0], 'o': [8, 0], 'p': [9, 0],
            '[': [10, 0], ']': [11, 0], '\\': [12, 0],
            'a': [1, 1], 's': [2, 1], 'd': [3, 1], 'f': [4, 1], 'g': [5, 1],
            'h': [6, 1], 'j': [7, 1], 'k': [8, 1], 'l': [9, 1],
            ';': [10, 1], "'": [11, 1],
            'z': [1.5, 2], 'x': [2.5, 2], 'c': [3.5, 2], 'v': [4.5, 2], 'b': [5.5, 2],
            'n': [6.5, 2], 'm': [7.5, 2], ',': [8.5, 2], '.': [9.5, 2], '/': [10.5, 2]
        };
        const KEY_SCALE_X = 7.7;
        const KEY_SCALE_Y = 33.33;
        const KEY_WIDTH = 7.0;
        const KEY_HEIGHT = 28.0;
        const keyElements = {};
        const SLOPPINESS_VARIANTS = 5;
        const SLOPPINESS_AMPLITUDE = 3.5;
        const ANIMATION_SLOPPINESS_AMPLITUDE = 4.5;
        const IDLE_LOOP_PADDING = 0.4;

        function renderKeyboard() {
            keyboard.innerHTML = '';
            for (const [char, [x, y]] of Object.entries(KEYBOARD_LAYOUT)) {
                const key = document.createElement('div');
                key.className = 'key';
                key.textContent = char;
                key.style.left = `${x * KEY_SCALE_X}%`;
                key.style.top = `${y * KEY_SCALE_Y}%`;
                key.dataset.char = char;
                keyboard.appendChild(key);
                keyElements[char.toLowerCase()] = key;
            }
        }

        let highlightTimeout = null;
        function highlightKey(char) {
            if (!char) return;
            const key = keyElements[char.toLowerCase()];
            if (!key) return;
            document.querySelectorAll('.key.active').forEach(k => k.classList.remove('active'));
            if (highlightTimeout) clearTimeout(highlightTimeout);
            key.classList.add('active');
            highlightTimeout = setTimeout(() => key.classList.remove('active'), 200);
        }

        function getSwipePath(swipe) {
            const path = [];
            for (const char of swipe.toLowerCase()) {
                if (KEYBOARD_LAYOUT[char]) path.push(KEYBOARD_LAYOUT[char]);
            }
            return path;
        }

        let animationId = null, currentPath = [], currentChars = [], keyTimestamps = [];
        let animationPathPoints = [];
        let animationVariant = 0;

        function seedFrom(input) {
            let hash = 1469598103934665603n;
            for (const byte of new TextEncoder().encode(input)) {
                hash ^= BigInt(byte);
                hash = (hash * 1099511628211n) & 0xFFFFFFFFFFFFFFFFn;
            }
            return hash;
        }

        function nextRandom(state) {
            const next = (state * 6364136223846793005n + 1n) & 0xFFFFFFFFFFFFFFFFn;
            const value = Number(next >> 33n) / (2 ** 31);
            return { value, state: next };
        }

        function jitteredPath(points, seed, variant, amplitude) {
            const jittered = [];
            for (let i = 0; i < points.length; i++) {
                // Stable seed for each point based on its index and the variant
                // this prevents the entire path from shifting when new characters are added
                let state = (BigInt(i) * 0x12345678n) ^ (BigInt(variant) * 0x87654321n);
                state &= 0xFFFFFFFFFFFFFFFFn;
                
                let rndX, rndY;
                ({ value: rndX, state } = nextRandom(state));
                ({ value: rndY, state } = nextRandom(state));
                
                const dx = (rndX - 0.5) * amplitude;
                const dy = (rndY - 0.5) * amplitude;
                jittered.push([points[i][0] + dx / KEY_SCALE_X, points[i][1] + dy / KEY_SCALE_Y]);
            }
            return jittered;
        }

        function drawPath(ctx, points, rect) {
            if (points.length < 1) return;
            const toPixel = ([x, y]) => [
                (x * KEY_SCALE_X + KEY_WIDTH / 2) / 100 * rect.width,
                (y * KEY_SCALE_Y + KEY_HEIGHT / 2) / 100 * rect.height
            ];

            const p = points.map(toPixel);
            ctx.moveTo(p[0][0], p[0][1]);

            if (p.length === 2) {
                ctx.lineTo(p[1][0], p[1][1]);
            } else if (p.length > 2) {
                // Pin the first segment to its midpoint
                const mid0X = (p[0][0] + p[1][0]) * 0.5;
                const mid0Y = (p[0][1] + p[1][1]) * 0.5;
                ctx.lineTo(mid0X, mid0Y);

                for (let i = 1; i < p.length - 1; i++) {
                    const curr = p[i];
                    const next = p[i + 1];
                    const midX = (curr[0] + next[0]) * 0.5;
                    const midY = (curr[1] + next[1]) * 0.5;
                    ctx.quadraticCurveTo(curr[0], curr[1], midX, midY);
                }
                ctx.lineTo(p[p.length - 1][0], p[p.length - 1][1]);
            }
        }

        function stopAnimation() {
            if (animationId) { cancelAnimationFrame(animationId); animationId = null; }
            document.querySelectorAll('.key.active').forEach(k => k.classList.remove('active'));
        }

        function drawStaticPath(swipe, timestamps, isCommitted) {
            stopAnimation();
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width * devicePixelRatio;
            canvas.height = rect.height * devicePixelRatio;
            ctx.scale(devicePixelRatio, devicePixelRatio);
            ctx.clearRect(0, 0, rect.width, rect.height);
            currentPath = getSwipePath(swipe);
            if (currentPath.length < 1) return;
            keyTimestamps = [];
            currentChars = [];
            for (let i = 0; i < swipe.length; i++) {
                const char = swipe[i].toLowerCase();
                if (KEYBOARD_LAYOUT[char]) {
                    keyTimestamps.push(timestamps[i] || 0);
                    currentChars.push(char);
                }
            }

            const showSimulation = isCommitted && currentPath.length >= 2;

            if (showSimulation) {
                const seed = seedFrom(swipe);
                for (let variant = 0; variant < SLOPPINESS_VARIANTS; variant++) {
                    const variantPath = jitteredPath(currentPath, seed, variant, SLOPPINESS_AMPLITUDE);
                    const opacity = 0.06 + (variant * 0.01);
                    ctx.beginPath();
                    ctx.strokeStyle = `rgba(50, 100, 200, ${opacity})`;
                    ctx.lineWidth = 1.7;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    drawPath(ctx, variantPath, rect);
                    ctx.stroke();
                }
            }

            if (currentPath.length >= 2) {
                ctx.beginPath();
                ctx.strokeStyle = `rgba(50, 100, 200, ${isCommitted ? 0.20 : 0.35})`;
                ctx.lineWidth = isCommitted ? 2.4 : 3.0;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                drawPath(ctx, currentPath, rect);
                ctx.stroke();
            }
        }

        function startAnimation() {
            if (currentPath.length < 2) return;
            const rect = canvas.parentElement.getBoundingClientRect();

            const seed = seedFrom(currentChars.join(''));
            animationVariant = Number(seed % BigInt(SLOPPINESS_VARIANTS));
            animationPathPoints = jitteredPath(currentPath, seed, animationVariant, ANIMATION_SLOPPINESS_AMPLITUDE);

            if (keyTimestamps.length >= 2) {
                const n = keyTimestamps.length;
                const rawDuration = keyTimestamps[n - 1] - keyTimestamps[0];
                const desiredDurationMs = Math.min(1200, Math.max(500, n * 50));
                const useSynthetic = !Number.isFinite(rawDuration) || rawDuration < 250 || rawDuration > 4000;
                if (useSynthetic) {
                    const step = desiredDurationMs / (n - 1);
                    keyTimestamps = Array.from({ length: n }, (_, i) => i * step);
                } else {
                    const clamped = Math.min(2000, Math.max(700, rawDuration));
                    const scale = rawDuration > 0 ? (clamped / rawDuration) : 1;
                    const base = keyTimestamps[0];
                    keyTimestamps = keyTimestamps.map(t => (t - base) * scale);
                }
            }

            animateLoop(rect);
        }

        function animateLoop(rect) {
            const points = animationPathPoints;
            const timeSamples = keyTimestamps;
            if (timeSamples.length < 2 || points.length < 2) return;
            const totalDuration = timeSamples[timeSamples.length - 1] - timeSamples[0];
            const startTime = performance.now();
            const toPixel = ([x, y]) => [
                (x * KEY_SCALE_X + KEY_WIDTH / 2) / 100 * rect.width,
                (y * KEY_SCALE_Y + KEY_HEIGHT / 2) / 100 * rect.height
            ];

            function interpolatedPointAt(time, wrap) {
                if (timeSamples.length < 2 || points.length < 2) return null;
                const start = timeSamples[0];
                const end = timeSamples[timeSamples.length - 1];
                const total = end - start;
                if (total <= 0) return null;

                const target = wrap
                    ? (function() {
                        const normalized = (time - start) % total;
                        const safeNorm = normalized < 0 ? normalized + total : normalized;
                        return start + safeNorm;
                    })()
                    : (function() {
                        if (time < start || time > end) return null;
                        return time;
                    })();
                if (target === null) return null;

                let segmentIdx = 0;
                for (let i = 0; i < timeSamples.length - 1; i++) {
                    if (target >= timeSamples[i] && target < timeSamples[i + 1]) {
                        segmentIdx = i;
                        break;
                    } else if (target >= end) {
                        segmentIdx = timeSamples.length - 2;
                    }
                }

                const segStart = timeSamples[segmentIdx];
                const segEnd = timeSamples[segmentIdx + 1];
                const segDiff = segEnd - segStart;
                const progress = Math.min(1, (target - segStart) / Math.max(segDiff, 0.001));
                const startPoint = points[segmentIdx];
                const endPoint = points[segmentIdx + 1];
                const x = startPoint[0] + (endPoint[0] - startPoint[0]) * progress;
                const y = startPoint[1] + (endPoint[1] - startPoint[1]) * progress;
                return { point: [x, y], segmentIdx };
            }

            function draw() {
                ctx.clearRect(0, 0, rect.width, rect.height);
                const loopDuration = totalDuration + IDLE_LOOP_PADDING * 1000;
                const elapsed = (performance.now() - startTime) % loopDuration;

                if (elapsed >= totalDuration) {
                    if (points.length > 0) {
                        const lastIdx = points.length - 1;
                        const [px, py] = toPixel(points[lastIdx]);
                        
                        ctx.beginPath();
                        ctx.strokeStyle = 'rgba(50, 100, 200, 0.7)';
                        ctx.lineWidth = 3.0;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        drawPath(ctx, points, rect);
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.fillStyle = 'rgba(50, 100, 200, 0.9)';
                        ctx.arc(px, py, 6, 0, Math.PI * 2);
                        ctx.fill();

                        if (currentChars.length > 0) {
                            highlightKey(currentChars[currentChars.length - 1]);
                        }
                    }
                } else {
                    const currentTime = timeSamples[0] + elapsed;
                    const result = interpolatedPointAt(currentTime, false);
                    if (!result) {
                        animationId = requestAnimationFrame(draw);
                        return;
                    }

                    const { point: currPoint, segmentIdx } = result;
                    if (segmentIdx >= 0 && segmentIdx < currentChars.length) {
                        highlightKey(currentChars[segmentIdx]);
                    }

                    const animPoints = points.slice(0, segmentIdx + 1);
                    animPoints.push(currPoint);

                    ctx.beginPath();
                    ctx.strokeStyle = 'rgba(50, 100, 200, 0.7)';
                    ctx.lineWidth = 3.0;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    drawPath(ctx, animPoints, rect);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.fillStyle = 'rgba(50, 100, 200, 0.9)';
                    const [pixelX, pixelY] = toPixel(currPoint);
                    ctx.arc(pixelX, pixelY, 6, 0, Math.PI * 2);
                    ctx.fill();
                }

                animationId = requestAnimationFrame(draw);
            }
            draw();
        }

        renderKeyboard();
        async function main() {
            status.textContent = 'Loading WASM...';
            await init();
            status.textContent = 'Fetching dictionary...';
            const res = await fetch(DICT_URL);
            const freqText = await res.text();
            status.textContent = 'Initializing...';
            init_dictionary(freqText);
            status.innerHTML = '<span>Ready</span><span class="typing-stats"></span>';
            input.disabled = false;
            input.focus();
            const modeWordBtn = document.getElementById('mode-word');
            const modeSentenceBtn = document.getElementById('mode-sentence');
            const sentenceContainer = document.getElementById('sentence-container');
            const sentenceDisplay = document.getElementById('sentence-display');
            const sentenceStats = document.getElementById('sentence-stats');
            let pendingTimer = null, pendingRaf = null, predictionId = 0;
            const DEBOUNCE_THRESHOLD = 15, DEBOUNCE_DELAY = 450;
            let charTimestamps = [], lastInputLength = 0;
            let mode = 'word', sentenceState = 'idle', sentenceWords = [], wordHistory = [], awaitingPredictions = [], currentWordStartTime = null;
            let isWordCommitted = false;
            let isPlaybackActive = false;
            let playbackStartTime = 0;

            function cancelPending() {
                if (pendingTimer) { clearTimeout(pendingTimer); pendingTimer = null; }
                if (pendingRaf) { cancelAnimationFrame(pendingRaf); pendingRaf = null; }
                predictionId++;
                isPlaybackActive = false;
                isWordCommitted = false;
            }

            function renderPredictions(predictions, showBadges = false) {
                results.innerHTML = `<div class="prediction" style="font-weight:bold;opacity:0.6"><span class="word">Word</span><span class="score">Score</span><span class="popularity">Popularity</span></div>` + predictions.map((p, i) => `<div class="prediction"><span class="word">${showBadges ? `[${i + 1}] ` : ''}${p.word}</span><span class="score">${p.score.toFixed(3)}</span><span class="popularity">${p.freq.toFixed(3)}</span></div>`).join('');
            }

            function updateSentenceDisplay() {
                sentenceDisplay.innerHTML = (sentenceWords.length > 0 ? sentenceWords.join(' ') + ' ' : '') + '<span class="cursor"></span>';
            }

            function updateSentenceStats() {
                if (wordHistory.length === 0) { sentenceStats.textContent = ''; return; }
                const totalDuration = wordHistory.reduce((s, w) => s + w.duration, 0);
                const totalCharsTyped = wordHistory.reduce((s, w) => s + w.charsTyped, 0);
                const totalCharsSelected = wordHistory.reduce((s, w) => s + w.charsSelected, 0);
                const minutes = totalDuration / 60000;
                const physicalWpm = minutes > 0 ? Math.round((totalCharsTyped / 5) / minutes) : 0;
                const actualWpm = minutes > 0 ? Math.round((totalCharsSelected / 5) / minutes) : 0;
                sentenceStats.textContent = `${sentenceWords.length} words · ${totalCharsTyped}/${totalCharsSelected} chars · ${physicalWpm} physical / ${actualWpm} actual WPM`;
            }

            function clearCanvas() {
                const rect = canvas.parentElement.getBoundingClientRect();
                canvas.width = rect.width * devicePixelRatio;
                canvas.height = rect.height * devicePixelRatio;
                ctx.scale(devicePixelRatio, devicePixelRatio);
                ctx.clearRect(0, 0, rect.width, rect.height);
            }

            function selectPrediction(index) {
                if (index >= awaitingPredictions.length) return;
                const prediction = awaitingPredictions[index];
                const swipeLength = input.value.trim().length;
                const duration = performance.now() - currentWordStartTime;
                wordHistory.push({ word: prediction.word, charsTyped: swipeLength, charsSelected: prediction.word.length, duration });
                sentenceWords.push(prediction.word);
                input.value = '';
                charTimestamps = [];
                lastInputLength = 0;
                sentenceState = 'idle';
                awaitingPredictions = [];
                currentWordStartTime = null;
                isPlaybackActive = false;
                isWordCommitted = false;
                results.innerHTML = '';
                stopAnimation();
                clearCanvas();
                updateSentenceDisplay();
                updateSentenceStats();
                status.innerHTML = '<span>Ready for next word</span><span class="typing-stats"></span>';
            }

            function undoLastWord() {
                if (wordHistory.length === 0) return;
                wordHistory.pop();
                sentenceWords.pop();
                sentenceState = 'idle';
                awaitingPredictions = [];
                isPlaybackActive = false;
                isWordCommitted = false;
                results.innerHTML = '';
                updateSentenceDisplay();
                updateSentenceStats();
                status.innerHTML = '<span>Word removed</span><span class="typing-stats"></span>';
            }

            function setMode(newMode) {
                mode = newMode;
                modeWordBtn.classList.toggle('active', mode === 'word');
                modeSentenceBtn.classList.toggle('active', mode === 'sentence');
                sentenceContainer.classList.toggle('visible', mode === 'sentence');
                input.value = '';
                charTimestamps = [];
                lastInputLength = 0;
                sentenceState = 'idle';
                sentenceWords = [];
                wordHistory = [];
                awaitingPredictions = [];
                currentWordStartTime = null;
                isPlaybackActive = false;
                isWordCommitted = false;
                results.innerHTML = '';
                stopAnimation();
                clearCanvas();
                updateSentenceDisplay();
                updateSentenceStats();
                status.innerHTML = '<span>Ready</span><span class="typing-stats"></span>';
                input.focus();
            }

            modeWordBtn.addEventListener('click', () => setMode('word'));
            modeSentenceBtn.addEventListener('click', () => setMode('sentence'));

            function runPrediction(id) {
                if (id !== predictionId) return;
                const swipe = input.value.trim().toLowerCase();
                if (!swipe) { results.innerHTML = ''; status.innerHTML = '<span>Ready</span><span class="typing-stats"></span>'; return; }
                const start = performance.now();
                const json = predict_wasm(swipe, 5);
                const elapsed = ((performance.now() - start) / 1000).toFixed(3);
                const predictions = JSON.parse(json);
                if (mode === 'sentence') {
                    awaitingPredictions = predictions;
                    sentenceState = 'awaiting';
                    renderPredictions(predictions, true);
                    status.innerHTML = '<span>Press 1-5 to select, or start next word</span><span class="typing-stats"></span>';
                } else {
                    let typingStats = '';
                    if (charTimestamps.length >= 2) {
                        const typingTimeMs = charTimestamps[charTimestamps.length - 1] - charTimestamps[0];
                        const typingTimeSec = (typingTimeMs / 1000).toFixed(2);
                        const minutes = typingTimeMs / 60000;
                        const physicalWpm = minutes > 0 ? Math.round((swipe.length / 5) / minutes) : 0;
                        const firstWord = predictions.length > 0 ? predictions[0].word : '';
                        const actualWpm = minutes > 0 && firstWord ? Math.round((firstWord.length / 5) / minutes) : 0;
                        typingStats = `typed in ${typingTimeSec}s · ${physicalWpm} Physical · ${actualWpm} Actual WPM`;
                    }
                    status.innerHTML = `<span>Computed in ${elapsed}s</span><span class="typing-stats">${typingStats}</span>`;
                    renderPredictions(predictions, false);
                }
            }

            input.addEventListener('keydown', (e) => {
                if (mode !== 'sentence') return;
                if ((sentenceState === 'awaiting' || sentenceState === 'typing') && e.key >= '1' && e.key <= '5' && awaitingPredictions.length > 0) {
                    e.preventDefault();
                    const index = parseInt(e.key) - 1;
                    if (index < awaitingPredictions.length) selectPrediction(index);
                    return;
                }
                if (e.key === 'Backspace' && input.value === '' && wordHistory.length > 0) {
                    e.preventDefault();
                    undoLastWord();
                    return;
                }
                if (sentenceState === 'awaiting' && /^[a-z]$/i.test(e.key) && awaitingPredictions.length > 0) {
                    selectPrediction(0);
                }
            });

            input.addEventListener('input', () => {
                const swipe = input.value.trim();
                const now = performance.now();
                cancelPending();
                const id = predictionId;
                const currentLength = swipe.length;
                if (currentLength > lastInputLength) {
                    for (let i = lastInputLength; i < currentLength; i++) charTimestamps.push(now);
                } else if (currentLength < lastInputLength) {
                    charTimestamps = charTimestamps.slice(0, currentLength);
                }
                lastInputLength = currentLength;
                if (mode === 'sentence' && sentenceState === 'idle' && swipe.length > 0) {
                    sentenceState = 'typing';
                    currentWordStartTime = now;
                }
                drawStaticPath(swipe, [...charTimestamps], isWordCommitted);
                highlightKey(swipe[swipe.length - 1]);
                if (!swipe) {
                    charTimestamps = [];
                    lastInputLength = 0;
                    isPlaybackActive = false;
                    isWordCommitted = false;
                    if (mode === 'sentence') { sentenceState = 'idle'; awaitingPredictions = []; }
                    results.innerHTML = '';
                    status.innerHTML = '<span>Ready</span><span class="typing-stats"></span>';
                    return;
                }
                if (mode === 'sentence' && sentenceState === 'awaiting') { sentenceState = 'typing'; }
                const debounceDelay = mode === 'sentence' ? DEBOUNCE_DELAY : (swipe.length < DEBOUNCE_THRESHOLD ? 100 : DEBOUNCE_DELAY);
                pendingTimer = setTimeout(() => {
                    if (id !== predictionId) return;
                    isWordCommitted = true;
                    drawStaticPath(input.value.trim(), [...charTimestamps], true);
                    runPrediction(id);
                    if (charTimestamps.length >= 2) {
                        isPlaybackActive = true;
                        playbackStartTime = performance.now();
                        startAnimation();
                    }
                }, debounceDelay);
                if (mode === 'word' && swipe.length >= DEBOUNCE_THRESHOLD) {
                    status.innerHTML = '<span>Typing...</span><span class="typing-stats"></span>';
                } else if (mode === 'sentence') {
                    status.innerHTML = '<span>Typing...</span><span class="typing-stats"></span>';
                }
            });
        }
        main().catch(err => { status.textContent = 'Error: ' + err.message; console.error(err); });
    </script>
</body>
</html>